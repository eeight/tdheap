.\" ** You probably do not want to edit this file directly **
.\" It was generated using the DocBook XSL Stylesheets (version 1.69.1).
.\" Instead of manually editing it, you probably should edit the DocBook XML
.\" source for it and then use the DocBook XSL Stylesheets to regenerate it.
.TH "VALGRIND" "1" "06/01/2008" "Release 3.3.1" "Release 3.3.1"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
valgrind \- a suite of tools for debugging and profiling programs
.SH "SYNOPSIS"
.HP 9
\fBvalgrind\fR [[\fIvalgrind\fR]\ [\fIoptions\fR]] [\fIyour\-program\fR] [[\fIyour\-program\-options\fR]]
.SH "DESCRIPTION"
.PP
\fBValgrind\fR
is a flexible program for debugging and profiling Linux executables. It consists of a core, which provides a synthetic CPU in software, and a series of "tools", each of which is a debugging or profiling tool. The architecture is modular, so that new tools can be created easily and without disturbing the existing structure.
.PP
This manual page covers only basic usage and options. For more comprehensive information, please see the HTML documentation on your system:
\fI/usr/share/doc/valgrind/html/index.html\fR, or online:
\fIhttp://www.valgrind.org/docs/manual/index.html\fR.
.SH "INVOCATION"
.PP
\fBValgrind\fR
is typically invoked as follows:
.sp
.nf
    valgrind program args
.fi
.sp
This runs
\fBprogram\fR
(with arguments
\fBargs\fR) under Valgrind using the Memcheck tool. Memcheck performs a range of memory\-checking functions, including detecting accesses to uninitialised memory, misuse of allocated memory (double frees, access after free, etc.) and detecting memory leaks.
.PP
To use a different tool, use the
\fB\-\-tool\fR
option:
.sp
.nf
    valgrind \-\-tool=toolname program args
.fi
.PP
The following tools are available:
.TP 3
\(bu
\fBcachegrind\fR
is a cache simulator. It can be used to annotate every line of your program with the number of instructions executed and cache misses incurred.
.TP
\(bu
\fBcallgrind\fR
adds call graph tracing to cachegrind. It can be used to get call counts and inclusive cost for each call happening in your program. In addition to cachegrind, callgrind can annotate threads separately, and every instruction of disassembler output of your program with the number of instructions executed and cache misses incurred.
.TP
\(bu
\fBhelgrind\fR
spots potential race conditions in your program.
.TP
\(bu
\fBlackey\fR
is a sample tool that can be used as a template for generating your own tools. After the program terminates, it prints out some basic statistics about the program execution.
.TP
\(bu
\fBmassif\fR
is a heap profiler. It measures how much heap memory your program uses.
.TP
\(bu
\fBmemcheck\fR
is a fine\-grained memory checker.
.TP
\(bu
\fBnone\fR
performs no function \- it simply runs the program under Valgrind. This is typically used for debugging and benchmarking Valgrind.
.SH "BASIC OPTIONS"
.PP
These options work with all tools.
.TP
\fB\-h \-\-help\fR
Show help for all options, both for the core and for the selected tool.
.TP
\fB\-\-help\-debug\fR
Same as
\fB\-\-help\fR, but also lists debugging options which usually are only of use to Valgrind's developers.
.TP
\fB\-\-version\fR
Show the version number of the Valgrind core. Tools can have their own version numbers. There is a scheme in place to ensure that tools only execute when the core version is one they are known to work with. This was done to minimise the chances of strange problems arising from tool\-vs\-core version incompatibilities.
.TP
\fB\-q \-\-quiet\fR
Run silently, and only print error messages. Useful if you are running regression tests or have some other automated test machinery.
.TP
\fB\-v \-\-verbose\fR
Be more verbose. Gives extra information on various aspects of your program, such as: the shared objects loaded, the suppressions used, the progress of the instrumentation and execution engines, and warnings about unusual behaviour. Repeating the flag increases the verbosity level.
.TP
\fB\-d\fR
Emit information for debugging Valgrind itself. This is usually only of interest to the Valgrind developers. Repeating the flag produces more detailed output. If you want to send us a bug report, a log of the output generated by
\fB\-v \-v \-d \-d\fR
will make your report more useful.
.TP
\fB\-\-tool=<toolname> [default: memcheck] \fR
Run the Valgrind tool called
\fItoolname\fR, e.g. Memcheck, Cachegrind, etc.
.TP
\fB\-\-trace\-children=<yes|no> [default: no] \fR
When enabled, Valgrind will trace into sub\-processes initiated via the
\fIexec\fR
system call. This can be confusing and isn't usually what you want, so it is disabled by default.
.sp
Note that Valgrind does trace into the child of a
\fIfork\fR
(it would be difficult not to, since
\fIfork\fR
makes an identical copy of a process), so this option is arguably badly named. However, most children of
\fIfork\fR
calls immediately call
\fIexec\fR
anyway.
.TP
\fB\-\-child\-silent\-after\-fork=<yes|no> [default: no] \fR
When enabled, Valgrind will not show any debugging or logging output for the child process resulting from a
\fIfork\fR
call. This can make the output less confusing (although more misleading) when dealing with processes that create children. It is particularly useful in conjunction with
\fI\-\-trace\-children=\fR. Use of this flag is also strongly recommended if you are requesting XML output (\fI\-\-xml=yes\fR), since otherwise the XML from child and parent may become mixed up, which usually makes it useless.
.TP
\fB\-\-track\-fds=<yes|no> [default: no] \fR
When enabled, Valgrind will print out a list of open file descriptors on exit. Along with each file descriptor is printed a stack backtrace of where the file was opened and any details relating to the file descriptor such as the file name or socket details.
.TP
\fB\-\-time\-stamp=<yes|no> [default: no] \fR
When enabled, each message is preceded with an indication of the elapsed wallclock time since startup, expressed as days, hours, minutes, seconds and milliseconds.
.TP
\fB\-\-log\-fd=<number> [default: 2, stderr] \fR
Specifies that Valgrind should send all of its messages to the specified file descriptor. The default, 2, is the standard error channel (stderr). Note that this may interfere with the client's own use of stderr, as Valgrind's output will be interleaved with any output that the client sends to stderr.
.TP
\fB\-\-log\-file=<filename> \fR
Specifies that Valgrind should send all of its messages to the specified file. If the file name is empty, it causes an abort. There are three special format specifiers that can be used in the file name.
.sp
\fB%p\fR
is replaced with the current process ID. This is very useful for program that invoke multiple processes. WARNING: If you use
\fB\-\-trace\-children=yes\fR
and your program invokes multiple processes OR your program forks without calling exec afterwards, and you don't use this specifier (or the
\fB%q\fR
specifier below), the Valgrind output from all those processes will go into one file, possibly jumbled up, and possibly incomplete.
.sp
\fB%q{FOO}\fR
is replaced with the contents of the environment variable
\fIFOO\fR. If the
\fB{FOO}\fR
part is malformed, it causes an abort. This specifier is rarely needed, but very useful in certain circumstances (eg. when running MPI programs). The idea is that you specify a variable which will be set differently for each process in the job, for example
BPROC_RANK
or whatever is applicable in your MPI setup. If the named environment variable is not set, it causes an abort. Note that in some shells, the
\fB{\fR
and
\fB}\fR
characters may need to be escaped with a backslash.
.sp
\fB%%\fR
is replaced with
\fB%\fR.
.sp
If an
\fB%\fR
is followed by any other character, it causes an abort.
.TP
\fB\-\-log\-socket=<ip\-address:port\-number> \fR
Specifies that Valgrind should send all of its messages to the specified port at the specified IP address. The port may be omitted, in which case port 1500 is used. If a connection cannot be made to the specified socket, Valgrind falls back to writing output to the standard error (stderr). This option is intended to be used in conjunction with the
valgrind\-listener
program. For further details, see
the commentary
in the manual.
.SH "ERROR\-RELATED OPTIONS"
.PP
These options are used by all tools that can report errors, e.g. Memcheck, but not Cachegrind.
.TP
\fB\-\-xml=<yes|no> [default: no] \fR
When enabled, output will be in XML format. This is aimed at making life easier for tools that consume Valgrind's output as input, such as GUI front ends. Currently this option only works with Memcheck.
.TP
\fB\-\-xml\-user\-comment=<string> \fR
Embeds an extra user comment string at the start of the XML output. Only works when
\fB\-\-xml=yes\fR
is specified; ignored otherwise.
.TP
\fB\-\-demangle=<yes|no> [default: yes] \fR
Enable/disable automatic demangling (decoding) of C++ names. Enabled by default. When enabled, Valgrind will attempt to translate encoded C++ names back to something approaching the original. The demangler handles symbols mangled by g++ versions 2.X, 3.X and 4.X.
.sp
An important fact about demangling is that function names mentioned in suppressions files should be in their mangled form. Valgrind does not demangle function names when searching for applicable suppressions, because to do otherwise would make suppressions file contents dependent on the state of Valgrind's demangling machinery, and would also be slow and pointless.
.TP
\fB\-\-num\-callers=<number> [default: 12] \fR
By default, Valgrind shows twelve levels of function call names to help you identify program locations. You can change that number with this option. This can help in determining the program's location in deeply\-nested call chains. Note that errors are commoned up using only the top four function locations (the place in the current function, and that of its three immediate callers). So this doesn't affect the total number of errors reported.
.sp
The maximum value for this is 50. Note that higher settings will make Valgrind run a bit more slowly and take a bit more memory, but can be useful when working with programs with deeply\-nested call chains.
.TP
\fB\-\-error\-limit=<yes|no> [default: yes] \fR
When enabled, Valgrind stops reporting errors after 10,000,000 in total, or 1,000 different ones, have been seen. This is to stop the error tracking machinery from becoming a huge performance overhead in programs with many errors.
.TP
\fB\-\-error\-exitcode=<number> [default: 0] \fR
Specifies an alternative exit code to return if Valgrind reported any errors in the run. When set to the default value (zero), the return value from Valgrind will always be the return value of the process being simulated. When set to a nonzero value, that value is returned instead, if Valgrind detects any errors. This is useful for using Valgrind as part of an automated test suite, since it makes it easy to detect test cases for which Valgrind has reported errors, just by inspecting return codes.
.TP
\fB\-\-show\-below\-main=<yes|no> [default: no] \fR
By default, stack traces for errors do not show any functions that appear beneath
\fBmain()\fR
(or similar functions such as glibc's
\fB__libc_start_main()\fR, if
\fBmain()\fR
is not present in the stack trace); most of the time it's uninteresting C library stuff. If this option is enabled, those entries below
\fBmain()\fR
will be shown.
.TP
\fB\-\-suppressions=<filename> [default: $PREFIX/lib/valgrind/default.supp] \fR
Specifies an extra file from which to read descriptions of errors to suppress. You may use up to 100 extra suppression files.
.TP
\fB\-\-gen\-suppressions=<yes|no|all> [default: no] \fR
When set to
\fIyes\fR, Valgrind will pause after every error shown and print the line:
.sp
.nf
    \-\-\-\- Print suppression ? \-\-\- [Return/N/n/Y/y/C/c] \-\-\-\-
.fi
.sp
The prompt's behaviour is the same as for the
\fB\-\-db\-attach\fR
option (see below).
.sp
If you choose to, Valgrind will print out a suppression for this error. You can then cut and paste it into a suppression file if you don't want to hear about the error in the future.
.sp
When set to
\fIall\fR, Valgrind will print a suppression for every reported error, without querying the user.
.sp
This option is particularly useful with C++ programs, as it prints out the suppressions with mangled names, as required.
.sp
Note that the suppressions printed are as specific as possible. You may want to common up similar ones, eg. by adding wildcards to function names. Sometimes two different errors are suppressed by the same suppression, in which case Valgrind will output the suppression more than once, but you only need to have one copy in your suppression file (but having more than one won't cause problems). Also, the suppression name is given as
<insert a suppression name here>; the name doesn't really matter, it's only used with the
\fB\-v\fR
option which prints out all used suppression records.
.TP
\fB\-\-db\-attach=<yes|no> [default: no] \fR
When enabled, Valgrind will pause after every error shown and print the line:
.sp
.nf
    \-\-\-\- Attach to debugger ? \-\-\- [Return/N/n/Y/y/C/c] \-\-\-\-
.fi
.sp
Pressing
\fIRet\fR, or
\fIN Ret\fR
or
\fIn Ret\fR, causes Valgrind not to start a debugger for this error.
.sp
Pressing
\fIY Ret\fR
or
\fIy Ret\fR
causes Valgrind to start a debugger for the program at this point. When you have finished with the debugger, quit from it, and the program will continue. Trying to continue from inside the debugger doesn't work.
.sp
\fIC Ret\fR
or
\fIc Ret\fR
causes Valgrind not to start a debugger, and not to ask again.
.sp
\fBNote:\fR\fB\-\-db\-attach=yes\fR
conflicts with
\fB\-\-trace\-children=yes\fR. You can't use them together. Valgrind refuses to start up in this situation.
.sp
May 2002: this is a historical relic which could be easily fixed if it gets in your way. Mail us and complain if this is a problem for you.
.sp
Nov 2002: if you're sending output to a logfile or to a network socket, I guess this option doesn't make any sense. Caveat emptor.
.TP
\fB\-\-db\-command=<command> [default: gdb \-nw %f %p] \fR
Specify the debugger to use with the
\fB\-\-db\-attach\fR
command. The default debugger is gdb. This option is a template that is expanded by Valgrind at runtime.
%f
is replaced with the executable's file name and
%p
is replaced by the process ID of the executable.
.sp
This specifies how Valgrind will invoke the debugger. By default it will use whatever GDB is detected at build time, which is usually
/usr/bin/gdb. Using this command, you can specify some alternative command to invoke the debugger you want to use.
.sp
The command string given can include one or instances of the
%p
and
%f
expansions. Each instance of
%p
expands to the PID of the process to be debugged and each instance of
%f
expands to the path to the executable for the process to be debugged.
.sp
Since
<command>
is likely to contain spaces, you will need to put this entire flag in quotes to ensure it is correctly handled by the shell.
.TP
\fB\-\-input\-fd=<number> [default: 0, stdin] \fR
When using
\fB\-\-db\-attach=yes\fR
or
\fB\-\-gen\-suppressions=yes\fR, Valgrind will stop so as to read keyboard input from you when each error occurs. By default it reads from the standard input (stdin), which is problematic for programs which close stdin. This option allows you to specify an alternative file descriptor from which to read input.
.TP
\fB\-\-max\-stackframe=<number> [default: 2000000] \fR
The maximum size of a stack frame. If the stack pointer moves by more than this amount then Valgrind will assume that the program is switching to a different stack.
.sp
You may need to use this option if your program has large stack\-allocated arrays. Valgrind keeps track of your program's stack pointer. If it changes by more than the threshold amount, Valgrind assumes your program is switching to a different stack, and Memcheck behaves differently than it would for a stack pointer change smaller than the threshold. Usually this heuristic works well. However, if your program allocates large structures on the stack, this heuristic will be fooled, and Memcheck will subsequently report large numbers of invalid stack accesses. This option allows you to change the threshold to a different value.
.sp
You should only consider use of this flag if Valgrind's debug output directs you to do so. In that case it will tell you the new threshold you should specify.
.sp
In general, allocating large structures on the stack is a bad idea, because you can easily run out of stack space, especially on systems with limited memory or which expect to support large numbers of threads each with a small stack, and also because the error checking performed by Memcheck is more effective for heap\-allocated data than for stack\-allocated data. If you have to use this flag, you may wish to consider rewriting your code to allocate on the heap rather than on the stack.
.SH "MALLOC()\-RELATED OPTIONS"
.PP
For tools that use their own version of
malloc()
(e.g. Memcheck and Massif), the following options apply.
.TP
\fB\-\-alignment=<number> [default: 8] \fR
By default Valgrind's
\fBmalloc()\fR,
\fBrealloc()\fR, etc, return 8\-byte aligned addresses. This is standard for most processors. However, some programs might assume that
\fBmalloc()\fR
et al return 16\-byte or more aligned memory. The supplied value must be between 8 and 4096 inclusive, and must be a power of two.
.SH "UNCOMMON OPTIONS"
.PP
These options apply to all tools, as they affect certain obscure workings of the Valgrind core. Most people won't need to use these.
.TP
\fB\-\-run\-libc\-freeres=<yes|no> [default: yes] \fR
The GNU C library (\fBlibc.so\fR), which is used by all programs, may allocate memory for its own uses. Usually it doesn't bother to free that memory when the program ends\(emthere would be no point, since the Linux kernel reclaims all process resources when a process exits anyway, so it would just slow things down.
.sp
The glibc authors realised that this behaviour causes leak checkers, such as Valgrind, to falsely report leaks in glibc, when a leak check is done at exit. In order to avoid this, they provided a routine called
\fB__libc_freeres\fR
specifically to make glibc release all memory it has allocated. Memcheck therefore tries to run
\fB__libc_freeres\fR
at exit.
.sp
Unfortunately, in some very old versions of glibc,
\fB__libc_freeres\fR
is sufficiently buggy to cause segmentation faults. This was particularly noticeable on Red Hat 7.1. So this flag is provided in order to inhibit the run of
\fB__libc_freeres\fR. If your program seems to run fine on Valgrind, but segfaults at exit, you may find that
\fB\-\-run\-libc\-freeres=no\fR
fixes that, although at the cost of possibly falsely reporting space leaks in
\fIlibc.so\fR.
.TP
\fB\-\-sim\-hints=hint1,hint2,... \fR
Pass miscellaneous hints to Valgrind which slightly modify the simulated behaviour in nonstandard or dangerous ways, possibly to help the simulation of strange features. By default no hints are enabled. Use with caution! Currently known hints are:
.RS
.TP 3
\(bu
\fBlax\-ioctls: \fR
Be very lax about ioctl handling; the only assumption is that the size is correct. Doesn't require the full buffer to be initialized when writing. Without this, using some device drivers with a large number of strange ioctl commands becomes very tiresome.
.TP
\(bu
\fBenable\-inner: \fR
Enable some special magic needed when the program being run is itself Valgrind.
.RE
.TP
\fB\-\-kernel\-variant=variant1,variant2,...\fR
Handle system calls and ioctls arising from minor variants of the default kernel for this platform. This is useful for running on hacked kernels or with kernel modules which support nonstandard ioctls, for example. Use with caution. If you don't understand what this option does then you almost certainly don't need it. Currently known variants are:
.RS
.TP 3
\(bu
\fBbproc: \fR
Support the sys_broc system call on x86. This is for running on BProc, which is a minor variant of standard Linux which is sometimes used for building clusters.
.RE
.TP
\fB\-\-show\-emwarns=<yes|no> [default: no] \fR
When enabled, Valgrind will emit warnings about its CPU emulation in certain cases. These are usually not interesting.
.TP
\fB\-\-smc\-check=<none|stack|all> [default: stack] \fR
This option controls Valgrind's detection of self\-modifying code. Valgrind can do no detection, detect self\-modifying code on the stack, or detect self\-modifying code anywhere. Note that the default option will catch the vast majority of cases, as far as we know. Running with
\fIall\fR
will slow Valgrind down greatly. Running with
\fInone\fR
will rarely speed things up, since very little code gets put on the stack for most programs.
.sp
Some architectures (including ppc32 and ppc64) require programs which create code at runtime to flush the instruction cache in between code generation and first use. Valgrind observes and honours such instructions. Hence, on ppc32/Linux and ppc64/Linux, Valgrind always provides complete, transparent support for self\-modifying code. It is only on x86/Linux and amd64/Linux that you need to use this flag.
.SH "DEBUGGING VALGRIND OPTIONS"
.PP
There are also some options for debugging Valgrind itself. You shouldn't need to use them in the normal run of things. If you wish to see the list, use the
\fB\-\-help\-debug\fR
option.
.SH "MEMCHECK OPTIONS"
.TP
\fB\-\-leak\-check=<no|summary|yes|full> [default: summary] \fR
When enabled, search for memory leaks when the client program finishes. A memory leak means a malloc'd block, which has not yet been free'd, but to which no pointer can be found. Such a block can never be free'd by the program, since no pointer to it exists. If set to
\fIsummary\fR, it says how many leaks occurred. If set to
\fIfull\fR
or
\fIyes\fR, it gives details of each individual leak.
.TP
\fB\-\-show\-reachable=<yes|no> [default: no] \fR
When disabled, the memory leak detector only shows blocks for which it cannot find a pointer to at all, or it can only find a pointer to the middle of. These blocks are prime candidates for memory leaks. When enabled, the leak detector also reports on blocks which it could find a pointer to. Your program could, at least in principle, have freed such blocks before exit. Contrast this to blocks for which no pointer, or only an interior pointer could be found: they are more likely to indicate memory leaks, because you do not actually have a pointer to the start of the block which you can hand to
\fBfree\fR, even if you wanted to.
.TP
\fB\-\-leak\-resolution=<low|med|high> [default: low] \fR
When doing leak checking, determines how willing
\fBmemcheck\fR
is to consider different backtraces to be the same. When set to
\fIlow\fR, only the first two entries need match. When
\fImed\fR, four entries have to match. When
\fIhigh\fR, all entries need to match.
.sp
For hardcore leak debugging, you probably want to use
\fB\-\-leak\-resolution=high\fR
together with
\fB\-\-num\-callers=40\fR
or some such large number. Note however that this can give an overwhelming amount of information, which is why the defaults are 4 callers and low\-resolution matching.
.sp
Note that the
\fB\-\-leak\-resolution=\fR
setting does not affect
\fBmemcheck's\fR
ability to find leaks. It only changes how the results are presented.
.TP
\fB\-\-freelist\-vol=<number> [default: 10000000] \fR
When the client program releases memory using
\fBfree\fR
(in
C) or delete (C++), that memory is not immediately made available for re\-allocation. Instead, it is marked inaccessible and placed in a queue of freed blocks. The purpose is to defer as long as possible the point at which freed\-up memory comes back into circulation. This increases the chance that
\fBmemcheck\fR
will be able to detect invalid accesses to blocks for some significant period of time after they have been freed.
.sp
This flag specifies the maximum total size, in bytes, of the blocks in the queue. The default value is ten million bytes. Increasing this increases the total amount of memory used by
\fBmemcheck\fR
but may detect invalid uses of freed blocks which would otherwise go undetected.
.TP
\fB\-\-workaround\-gcc296\-bugs=<yes|no> [default: no] \fR
When enabled, assume that reads and writes some small distance below the stack pointer are due to bugs in gcc 2.96, and does not report them. The "small distance" is 256 bytes by default. Note that gcc 2.96 is the default compiler on some ancient Linux distributions (RedHat 7.X) and so you may need to use this flag. Do not use it if you do not have to, as it can cause real errors to be overlooked. A better alternative is to use a more recent gcc/g++ in which this bug is fixed.
.sp
You may also need to use this flag when working with gcc/g++ 3.X or 4.X on 32\-bit PowerPC Linux. This is because gcc/g++ generates code which occasionally accesses below the stack pointer, particularly for floating\-point to/from integer conversions. This is in violation of the 32\-bit PowerPC ELF specification, which makes no provision for locations below the stack pointer to be accessible.
.TP
\fB\-\-partial\-loads\-ok=<yes|no> [default: no] \fR
Controls how
\fBmemcheck\fR
handles word\-sized, word\-aligned loads from addresses for which some bytes are addressable and others are not. When
\fIyes\fR, such loads do not produce an address error. Instead, loaded bytes originating from illegal addresses are marked as uninitialised, and those corresponding to legal addresses are handled in the normal way.
.sp
When
\fIno\fR, loads from partially invalid addresses are treated the same as loads from completely invalid addresses: an illegal\-address error is issued, and the resulting bytes are marked as initialised.
.sp
Note that code that behaves in this way is in violation of the the ISO C/C++ standards, and should be considered broken. If at all possible, such code should be fixed. This flag should be used only as a last resort.
.TP
\fB\-\-undef\-value\-errors=<yes|no> [default: yes] \fR
Controls whether
\fBmemcheck\fR
detects dangerous uses of undefined value errors. Set this to
\fIno\fR
if you don't like seeing undefined value errors; it also has the side effect of speeding
\fBmemcheck\fR
up somewhat.
.TP
\fB\-\-malloc\-fill=<hexnumber> \fR
Fills blocks allocated by
malloc,
new, etc, but not by
calloc, with the specified byte. This can be useful when trying to shake out obscure memory corruption problems. The allocated area is still regarded by Memcheck as undefined \-\- this flag only affects its contents.
.TP
\fB\-\-free\-fill=<hexnumber> \fR
Fills blocks freed by
free,
delete, etc, with the specified byte. This can be useful when trying to shake out obscure memory corruption problems. The freed area is still regarded by Memcheck as not valid for access \-\- this flag only affects its contents.
.SH "CACHEGRIND OPTIONS"
.PP
Using command line options, you can manually specify the I1/D1/L2 cache configuration to simulate. For each cache, you can specify the size, associativity and line size. The size and line size are measured in bytes. The three items must be comma\-separated, but with no spaces, eg:
.sp
.nf
    valgrind \-\-tool=cachegrind \-\-I1=65535,2,64
.fi
.sp
You can specify one, two or three of the I1/D1/L2 caches. Any level not manually specified will be simulated using the configuration found in the normal way (via the CPUID instruction for automagic cache configuration, or failing that, via defaults).
.TP
\fB\-\-I1=<size>,<associativity>,<line size> \fR
Specify the size, associativity and line size of the level 1 instruction cache.
.TP
\fB\-\-D1=<size>,<associativity>,<line size> \fR
Specify the size, associativity and line size of the level 1 data cache.
.TP
\fB\-\-L2=<size>,<associativity>,<line size> \fR
Specify the size, associativity and line size of the level 2 cache.
.TP
\fB\-\-cachegrind\-out\-file=<file> \fR
Write the profile data to
file
rather than to the default output file,
cachegrind.out.<pid>. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option
\fB\-\-log\-file\fR. See
here
for details.
.TP
\fB\-\-cache\-sim=no|yes [yes] \fR
Enables or disables collection of cache access and miss counts.
.TP
\fB\-\-branch\-sim=no|yes [no] \fR
Enables or disables collection of branch instruction and misprediction counts. By default this is disabled as it slows Cachegrind down by approximately 25%. Note that you cannot specify
\-\-cache\-sim=no
and
\-\-branch\-sim=no
together, as that would leave Cachegrind with no information to collect.
.SH "CALLGRIND OPTIONS"
.TP
\fB\-\-help\fR
Show summary of options. This is a short version of this manual section.
.TP
\fB\-\-version\fR
Show version of callgrind.
.TP
\fB\-\-callgrind\-out\-file=<file> \fR
Write the profile data to
file
rather than to the default output file,
callgrind.out.<pid>. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option
\fB\-\-log\-file\fR. See
here
for details. When multiple dumps are made, the file name is modified further; see below.
.TP
\fB\-\-dump\-instr=<no|yes> [default: no] \fR
This specifies that event counting should be performed at per\-instruction granularity. This allows for assembly code annotation. Currently the results can only be displayed by KCachegrind.
.TP
\fB\-\-dump\-line=<no|yes> [default: yes] \fR
This specifies that event counting should be performed at source line granularity. This allows source annotation for sources which are compiled with debug information ("\-g").
.TP
\fB\-\-compress\-strings=<no|yes> [default: yes] \fR
This option influences the output format of the profile data. It specifies whether strings (file and function names) should be identified by numbers. This shrinks the file, but makes it more difficult for humans to read (which is not recommended in any case).
.TP
\fB\-\-compress\-pos=<no|yes> [default: yes] \fR
This option influences the output format of the profile data. It specifies whether numerical positions are always specified as absolute values or are allowed to be relative to previous numbers. This shrinks the file size,
.TP
\fB\-\-combine\-dumps=<no|yes> [default: no] \fR
When multiple profile data parts are to be generated, these parts are appended to the same output file if this option is set to "yes". Not recommended.
.TP
\fB\-\-dump\-every\-bb=<count> [default: 0, never] \fR
Dump profile data every <count> basic blocks. Whether a dump is needed is only checked when Valgrind's internal scheduler is run. Therefore, the minimum setting useful is about 100000. The count is a 64\-bit value to make long dump periods possible.
.TP
\fB\-\-dump\-before=<function> \fR
Dump when entering <function>
.TP
\fB\-\-zero\-before=<function> \fR
Zero all costs when entering <function>
.TP
\fB\-\-dump\-after=<function> \fR
Dump when leaving <function>
.TP
\fB\-\-instr\-atstart=<yes|no> [default: yes] \fR
Specify if you want Callgrind to start simulation and profiling from the beginning of the program. When set to
no, Callgrind will not be able to collect any information, including calls, but it will have at most a slowdown of around 4, which is the minimum Valgrind overhead. Instrumentation can be interactively switched on via
callgrind_control \-i on.
.sp
Note that the resulting call graph will most probably not contain
main, but will contain all the functions executed after instrumentation was switched on. Instrumentation can also programatically switched on/off. See the Callgrind include file
<callgrind.h>
for the macro you have to use in your source code.
.sp
For cache simulation, results will be less accurate when switching on instrumentation later in the program run, as the simulator starts with an empty cache at that moment. Switch on event collection later to cope with this error.
.TP
\fB\-\-collect\-atstart=<yes|no> [default: yes] \fR
Specify whether event collection is switched on at beginning of the profile run.
.sp
To only look at parts of your program, you have two possibilities:
.RS
.TP 3
1.
Zero event counters before entering the program part you want to profile, and dump the event counters to a file after leaving that program part.
.TP
2.
Switch on/off collection state as needed to only see event counters happening while inside of the program part you want to profile.
.RE
.IP
The second option can be used if the program part you want to profile is called many times. Option 1, i.e. creating a lot of dumps is not practical here.
.sp
Collection state can be toggled at entry and exit of a given function with the option
\-\-toggle\-collect. If you use this flag, collection state should be switched off at the beginning. Note that the specification of
\-\-toggle\-collect
implicitly sets
\-\-collect\-state=no.
.sp
Collection state can be toggled also by using a Valgrind Client Request in your application. For this, include
valgrind/callgrind.h
and specify the macro
CALLGRIND_TOGGLE_COLLECT
at the needed positions. This only will have any effect if run under supervision of the Callgrind tool.
.TP
\fB\-\-toggle\-collect=<function> \fR
Toggle collection on entry/exit of <function>.
.TP
\fB\-\-collect\-jumps=<no|yes> [default: no] \fR
This specifies whether information for (conditional) jumps should be collected. As above, callgrind_annotate currently is not able to show you the data. You have to use KCachegrind to get jump arrows in the annotated code.
.TP
\fB\-\-simulate\-cache=<yes|no> [default: no] \fR
Specify if you want to do full cache simulation. By default, only instruction read accesses will be profiled.
.TP
\fB\-\-simulate\-hwpref=<yes|no> [default: no] \fR
Specify whether simulation of a hardware prefetcher should be added which is able to detect stream access in the second level cache by comparing accesses to separate to each page. As the simulation can not decide about any timing issues of prefetching, it is assumed that any hardware prefetch triggered succeeds before a real access is done. Thus, this gives a best\-case scenario by covering all possible stream accesses.
.SH "MASSIF OPTIONS"
.TP
\fB\-\-heap=<yes|no> [default: yes] \fR
Specifies whether heap profiling should be done.
.TP
\fB\-\-heap\-admin=<number> [default: 8] \fR
If heap profiling is enabled, gives the number of administrative bytes per block to use. This should be an estimate of the average, since it may vary. For example, the allocator used by
glibc
requires somewhere between 4 to 15 bytes per block, depending on various factors. It also requires admin space for freed blocks, although Massif does not account for this.
.TP
\fB\-\-stacks=<yes|no> [default: yes] \fR
Specifies whether stack profiling should be done. This option slows Massif down greatly, and so is off by default. Note that Massif assumes that the main stack has size zero at start\-up. This is not true, but measuring the actual stack size is not easy, and it reflects the size of the part of the main stack that a user program actually has control over.
.TP
\fB\-\-depth=<number> [default: 30] \fR
Maximum depth of the allocation trees recorded for detailed snapshots. Increasing it will make Massif run somewhat more slowly, use more memory, and produce bigger output files.
.TP
\fB\-\-alloc\-fn=<name> \fR
Functions specified with this option will be treated as though they were a heap allocation function such as
\fBmalloc\fR. This is useful for functions that are wrappers to
\fBmalloc\fR
or
\fBnew\fR, which can fill up the allocation trees with uninteresting information. This option can be specified multiple times on the command line, to name multiple functions.
.sp
Note that overloaded C++ names must be written in full. Single quotes may be necessary to prevent the shell from breaking them up. For example:
.sp
.nf
\-\-alloc\-fn='operator new(unsigned, std::nothrow_t const&amp;)'
.fi
.sp
.sp
The full list of functions and operators that are by default considered allocation functions is as follows.
.sp
.nf
malloc
calloc
realloc
memalign
__builtin_new
__builtin_vec_new
operator new(unsigned)
operator new(unsigned long)
operator new[](unsigned)
operator new[](unsigned long)
operator new(unsigned, std::nothrow_t const&)
operator new[](unsigned, std::nothrow_t const&)
operator new(unsigned long, std::nothrow_t const&)
operator new[](unsigned long, std::nothrow_t const&)
.fi
.TP
\fB\-\-threshold=<m.n> [default: 1.0] \fR
The significance threshold for heap allocations, as a percentage. Allocation tree entries that account for less than this will be aggregated. Note that this should be specified in tandem with ms_print's option of the same name.
.TP
\fB\-\-peak\-inaccuracy=<m.n> [default: 1.0] \fR
Massif does not necessarily record the actual global memory allocation peak; by default it records a peak only when the global memory allocation size exceeds the previous peak by at least 1.0%. This is because there can be many local allocation peaks along the way, and doing a detailed snapshot for every one would be expensive and wasteful, as all but one of them will be later discarded. This inaccuracy can be changed (even to 0.0%) via this option, but Massif will run drastically slower as the number approaches zero.
.TP
\fB\-\-time\-unit=i|ms|B [default: i] \fR
The time unit used for the profiling. There are three possibilities: instructions executed (i), which is good for most cases; real (wallclock) time (ms, i.e. milliseconds), which is sometimes useful; and bytes allocated/deallocated on the heap and/or stack (B), which is useful for very short\-run programs, and for testing purposes, because it is the most reproducible across different machines.
.TP
\fB\-\-detailed\-freq=<n> [default: 10] \fR
Frequency of detailed snapshots. With
\-\-detailed\-freq=1, every snapshot is detailed.
.TP
\fB\-\-max\-snapshots=<n> [default: 100] \fR
The maximum number of snapshots recorded. If set to N, for all programs except very short\-running ones, the final number of snapshots will be between N/2 and N.
.TP
\fB\-\-massif\-out\-file=<file> [default: massif.out.%p] \fR
Write the profile data to
file
rather than to the default output file,
massif.out.<pid>. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option
\fB\-\-log\-file\fR. See
???
for details.
.TP
\fB\-\-alignment=<n> [default: 1.0] \fR
The minimum alignment (and thus size) of heap blocks.
.SH "HELGRIND OPTIONS"
.TP
\fB\-\-happens\-before=none|threads|all [default: all] \fR
Helgrind always regards locks as the basis for inter\-thread synchronisation. However, by default, before reporting a race error, Helgrind will also check whether certain other kinds of inter\-thread synchronisation events happened. It may be that if such events took place, then no race really occurred, and so no error needs to be reported. See
above
for a discussion of transfers of exclusive ownership states between threads.
.sp
With
\fI\-\-happens\-before=all\fR, the following events are regarded as sources of synchronisation: thread creation/joinage, condition variable signal/broadcast/waits, and semaphore posts/waits.
.sp
With
\fI\-\-happens\-before=threads\fR, only thread creation/joinage events are regarded as sources of synchronisation.
.sp
With
\fI\-\-happens\-before=none\fR, no events (apart, of course, from locking) are regarded as sources of synchronisation.
.sp
Changing this setting from the default will increase your false\-error rate but give little or no gain. The only advantage is that
\fB\-\-happens\-before=threads\fR
and
\fB\-\-happens\-before=none\fR
should make Helgrind less and less sensitive to the scheduling of threads, and hence the output more and more repeatable across runs.
.TP
\fB\-\-trace\-addr=0xXXYYZZ \fR and \fB\-\-trace\-level=0|1|2 [default: 1] \fR
Requests that Helgrind produces a log of all state changes to location 0xXXYYZZ. This can be helpful in tracking down tricky races.
\fI\-\-trace\-level\fR
controls the verbosity of the log. At the default setting (1), a one\-line summary of is printed for each state change. At level 2 a complete stack trace is printed for each state change.
.SH "LACKEY OPTIONS"
.TP
\fB\-\-basic\-counts=<no|yes> [default: yes] \fR
Count basic events, as described above.
.TP
\fB\-\-detailed\-counts=<no|yes> [default: no] \fR
Count loads, stores and alu ops, differentiated by their IR types.
.TP
\fB\-\-fnname=<name> [default: _dl_runtime_resolve()] \fR
Count calls to the function <name>.
.TP
\fB\-\-trace\-mem=<no|yes> [default: no] \fR
Produce a log of all memory references, as described above.
.TP
\fB\-\-trace\-superblocks=<no|yes> [default: no] \fR
Print a line of text giving the address of each superblock (single entry, multiple exit chunk of code) executed by the program.
.SH "SEE ALSO"
.PP
\fI/usr/share/doc/valgrind/html/index.html\fR, and/or
\fIhttp://www.valgrind.org/docs/manual/index.html\fR.
.SH "AUTHOR"
.PP
This manpage has been written by Andres Roldan <aroldan@debian.org> for the Debian Project, but can be used for any other distribution.
.PP
Updated, rearranged and expanded by Robert Walsh <rjwalsh@durables.org> for the 2.4.0 release, and by other Valgrind developers subsequently.
